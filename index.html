<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>儿童国际象棋走法练习</title>
  <style>
    :root {
      --bg1: #fff1c9;
      --bg2: #ffd6a6;
      --ink: #23212b;
      --card: rgba(255, 255, 255, 0.78);
      --accent: #ff6b35;
      --accent-2: #2a9d8f;
      --good: #198754;
      --bad: #d90429;
      --gold: #f4a261;
      --board-light: #f4e7d3;
      --board-dark: #b07d4f;
      --hint: #4f46e5;
      --target: #ffd166;
      --choice: rgba(42, 157, 143, 0.22);
      --wrong: rgba(217, 4, 41, 0.22);
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100vh;
      font-family: "Fredoka", "Trebuchet MS", "PingFang SC", "Hiragino Sans GB",
        "Microsoft YaHei", sans-serif;
      color: var(--ink);
      background:
        radial-gradient(circle at 12% 18%, rgba(255, 255, 255, 0.8), transparent 45%),
        radial-gradient(circle at 88% 12%, rgba(255, 130, 92, 0.35), transparent 42%),
        radial-gradient(circle at 80% 90%, rgba(42, 157, 143, 0.28), transparent 44%),
        linear-gradient(180deg, var(--bg1), var(--bg2));
      display: grid;
      place-items: center;
      padding: 16px;
    }

    .app {
      width: min(1100px, 100%);
      background: var(--card);
      backdrop-filter: blur(8px);
      border: 2px solid rgba(255, 255, 255, 0.65);
      border-radius: 22px;
      box-shadow: 0 18px 40px rgba(78, 52, 24, 0.16);
      padding: 18px;
      display: grid;
      grid-template-columns: 360px 1fr;
      gap: 16px;
    }

    .panel {
      background: rgba(255, 255, 255, 0.92);
      border-radius: 18px;
      padding: 16px;
      box-shadow: inset 0 0 0 1px rgba(0, 0, 0, 0.04);
    }

    h1 {
      margin: 0 0 10px;
      font-size: 1.4rem;
      line-height: 1.1;
    }

    .subtitle {
      margin: 0 0 14px;
      color: #5a5564;
      font-size: 0.94rem;
    }

    .score-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 10px;
      margin: 14px 0;
    }

    .stat {
      border-radius: 14px;
      padding: 10px 12px;
      background: linear-gradient(160deg, #fff, #fff7ef);
      border: 1px solid rgba(0, 0, 0, 0.06);
    }

    .stat .label {
      color: #6a6473;
      font-size: 0.82rem;
    }

    .stat .value {
      font-size: 1.3rem;
      font-weight: 700;
      margin-top: 2px;
    }

    .lesson-chip {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      background: #fff3e8;
      border: 1px solid rgba(255, 107, 53, 0.25);
      padding: 8px 10px;
      border-radius: 999px;
      font-weight: 600;
      margin-bottom: 10px;
    }

    .piece-big {
      font-size: 1.4rem;
      line-height: 1;
    }

    .instruction {
      font-size: 1rem;
      line-height: 1.35;
      margin: 10px 0;
      padding: 12px;
      border-radius: 14px;
      background: #f7fbff;
      border: 1px solid rgba(79, 70, 229, 0.12);
    }

    .rule-box {
      margin-top: 10px;
      padding: 12px;
      border-radius: 14px;
      background: #effaf8;
      border: 1px solid rgba(42, 157, 143, 0.16);
      font-size: 0.92rem;
      line-height: 1.4;
    }

    .message {
      min-height: 52px;
      margin-top: 12px;
      padding: 10px 12px;
      border-radius: 12px;
      background: #fff;
      border: 1px dashed rgba(0, 0, 0, 0.12);
      font-size: 0.94rem;
      line-height: 1.4;
    }

    .message.good {
      border-style: solid;
      border-color: rgba(25, 135, 84, 0.28);
      background: rgba(25, 135, 84, 0.08);
      color: #0f5a37;
    }

    .message.bad {
      border-style: solid;
      border-color: rgba(217, 4, 41, 0.28);
      background: rgba(217, 4, 41, 0.06);
      color: #8d1224;
    }

    .progress-title {
      margin: 16px 0 10px;
      font-weight: 700;
      font-size: 0.95rem;
    }

    .piece-list {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
    }

    .piece-pill {
      border-radius: 12px;
      padding: 8px 10px;
      border: 1px solid rgba(0, 0, 0, 0.06);
      background: #fff;
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 0.9rem;
    }

    .piece-pill.done {
      background: #f0fff9;
      border-color: rgba(25, 135, 84, 0.25);
    }

    .piece-pill .tick {
      color: var(--good);
      font-weight: 700;
    }

    .board-wrap {
      background: rgba(255, 255, 255, 0.92);
      border-radius: 18px;
      padding: 14px;
      box-shadow: inset 0 0 0 1px rgba(0, 0, 0, 0.04);
    }

    .board-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
      margin-bottom: 10px;
      flex-wrap: wrap;
    }

    .attempt-badges {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    .badge {
      padding: 6px 10px;
      border-radius: 999px;
      font-size: 0.84rem;
      border: 1px solid rgba(0, 0, 0, 0.08);
      background: #fff;
    }

    .badge.highlight {
      background: #fff7dc;
      border-color: rgba(244, 162, 97, 0.35);
    }

    .board {
      width: min(100%, 620px);
      aspect-ratio: 1;
      margin: 0 auto;
      display: grid;
      grid-template-columns: repeat(8, 1fr);
      grid-template-rows: repeat(8, 1fr);
      border-radius: 16px;
      overflow: hidden;
      border: 3px solid rgba(78, 52, 24, 0.25);
      box-shadow: 0 10px 20px rgba(30, 20, 10, 0.08);
      user-select: none;
      touch-action: manipulation;
    }

    .square {
      position: relative;
      display: grid;
      place-items: center;
      cursor: pointer;
      font-size: clamp(22px, 4vw, 34px);
      transition: transform 120ms ease, filter 120ms ease;
    }

    .square:hover {
      filter: brightness(1.05);
    }

    .square:active {
      transform: scale(0.98);
    }

    .light {
      background: var(--board-light);
    }

    .dark {
      background: var(--board-dark);
    }

    .square.origin::after {
      content: "";
      position: absolute;
      inset: 7%;
      border-radius: 12px;
      border: 3px solid var(--hint);
      box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.55) inset;
      pointer-events: none;
    }

    .square.target::before {
      content: "";
      position: absolute;
      inset: 24%;
      border-radius: 999px;
      background: rgba(255, 209, 102, 0.85);
      border: 2px solid rgba(109, 74, 0, 0.26);
      pointer-events: none;
    }

    .square.enemy::before {
      content: "●";
      position: absolute;
      font-size: 16px;
      color: #b00020;
      top: 4px;
      right: 5px;
      opacity: 0.9;
      pointer-events: none;
    }

    .square.valid-hint::after {
      content: "";
      position: absolute;
      inset: 28%;
      border-radius: 999px;
      background: var(--choice);
      pointer-events: none;
    }

    .square.wrong-click {
      box-shadow: inset 0 0 0 4px rgba(217, 4, 41, 0.55);
      background-image: linear-gradient(var(--wrong), var(--wrong));
    }

    .coord {
      position: absolute;
      left: 4px;
      bottom: 2px;
      font-size: 10px;
      line-height: 1;
      opacity: 0.72;
      font-weight: 700;
    }

    .piece {
      position: relative;
      z-index: 1;
      text-shadow: 0 1px 0 rgba(255, 255, 255, 0.6);
    }

    .piece.white {
      color: #ffffff;
      -webkit-text-stroke: 1px rgba(30, 30, 30, 0.45);
    }

    .piece.black {
      color: #1f2937;
    }

    .controls {
      margin-top: 12px;
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }

    button {
      border: none;
      border-radius: 12px;
      padding: 10px 14px;
      font: inherit;
      font-weight: 700;
      cursor: pointer;
      color: #fff;
      background: linear-gradient(180deg, #ff7f50, #ff5c2b);
      box-shadow: 0 8px 14px rgba(255, 92, 43, 0.22);
    }

    button.secondary {
      background: linear-gradient(180deg, #3bb4a7, #229287);
      box-shadow: 0 8px 14px rgba(34, 146, 135, 0.18);
    }

    button.ghost {
      color: #3b3447;
      background: #fff;
      border: 1px solid rgba(0, 0, 0, 0.1);
      box-shadow: none;
    }

    button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

    @media (max-width: 920px) {
      .app {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
  <main class="app">
    <section class="panel">
      <h1>国际象棋走法训练营</h1>
      <p class="subtitle">点棋盘完成练习，帮助小朋友学会每个棋子的走法。</p>

      <div class="score-grid">
        <div class="stat">
          <div class="label">总分</div>
          <div class="value" id="totalScore">0</div>
        </div>
        <div class="stat">
          <div class="label">完成题数</div>
          <div class="value" id="solvedCount">0</div>
        </div>
        <div class="stat">
          <div class="label">当前尝试次数</div>
          <div class="value" id="tryCount">1</div>
        </div>
        <div class="stat">
          <div class="label">本题最高可得</div>
          <div class="value" id="currentPotential">100</div>
        </div>
      </div>

      <div class="lesson-chip">
        <span class="piece-big" id="pieceSymbolChip">♕</span>
        <span id="pieceNameChip">皇后练习</span>
      </div>

      <div class="instruction" id="instructionText"></div>
      <div class="rule-box" id="ruleText"></div>

      <div class="message" id="messageBox">点击棋盘上的一个格子开始吧！</div>

      <div class="progress-title">六种棋子学习进度</div>
      <div class="piece-list" id="pieceProgress"></div>

      <div class="controls">
        <button id="nextBtn" class="secondary" disabled>下一题</button>
        <button id="hintBtn" class="ghost">显示提示点</button>
        <button id="resetBtn">重新开始</button>
      </div>
    </section>

    <section class="board-wrap">
      <div class="board-header">
        <div><strong>棋盘练习区</strong> <span id="taskMeta"></span></div>
        <div class="attempt-badges">
          <span class="badge highlight">第一次答对：100分</span>
          <span class="badge">第二次答对：50分</span>
          <span class="badge">第三次及以上：25分</span>
        </div>
      </div>
      <div class="board" id="board"></div>
    </section>
  </main>

  <script>
    const FILES = "abcdefgh".split("");

    const pieces = {
      king: {
        key: "king",
        name: "国王",
        symbol: "♔",
        rule: "国王每次走 1 格，可以向任意方向走（上下左右和斜线都行）。",
      },
      queen: {
        key: "queen",
        name: "皇后",
        symbol: "♕",
        rule: "皇后走得最厉害：直线和斜线都能走，而且可以走很多格。",
      },
      rook: {
        key: "rook",
        name: "车",
        symbol: "♖",
        rule: "车走直线：横着走或竖着走，可以走很多格。",
      },
      bishop: {
        key: "bishop",
        name: "象",
        symbol: "♗",
        rule: "象走斜线：只能斜着走，可以走很多格。",
      },
      knight: {
        key: "knight",
        name: "马",
        symbol: "♘",
        rule: "马走“日”字：先走 2 格，再拐 1 格。马可以跳过别的棋子。",
      },
      pawn: {
        key: "pawn",
        name: "兵",
        symbol: "♙",
        rule: "兵通常向前走：一次 1 格；在起点时可以走 2 格。吃子时是斜前方 1 格。",
      },
    };

    const pieceOrder = ["king", "queen", "rook", "bishop", "knight", "pawn"];

    const state = {
      totalScore: 0,
      solvedCount: 0,
      triesForCurrent: 0,
      currentTask: null,
      wrongClicks: new Set(),
      showHints: false,
      learnedPieces: new Set(),
      lessonQueue: [],
      cycle: 1,
    };

    const el = {
      board: document.getElementById("board"),
      totalScore: document.getElementById("totalScore"),
      solvedCount: document.getElementById("solvedCount"),
      tryCount: document.getElementById("tryCount"),
      currentPotential: document.getElementById("currentPotential"),
      pieceSymbolChip: document.getElementById("pieceSymbolChip"),
      pieceNameChip: document.getElementById("pieceNameChip"),
      instructionText: document.getElementById("instructionText"),
      ruleText: document.getElementById("ruleText"),
      messageBox: document.getElementById("messageBox"),
      pieceProgress: document.getElementById("pieceProgress"),
      taskMeta: document.getElementById("taskMeta"),
      nextBtn: document.getElementById("nextBtn"),
      hintBtn: document.getElementById("hintBtn"),
      resetBtn: document.getElementById("resetBtn"),
    };

    function xyToIndex(x, y) {
      return y * 8 + x;
    }

    function indexToXY(i) {
      return { x: i % 8, y: Math.floor(i / 8) };
    }

    function inBoard(x, y) {
      return x >= 0 && x < 8 && y >= 0 && y < 8;
    }

    function coordName(index) {
      const { x, y } = indexToXY(index);
      return `${FILES[x]}${8 - y}`;
    }

    function shuffle(arr) {
      const clone = [...arr];
      for (let i = clone.length - 1; i > 0; i -= 1) {
        const j = Math.floor(Math.random() * (i + 1));
        [clone[i], clone[j]] = [clone[j], clone[i]];
      }
      return clone;
    }

    function ensureLessonQueue() {
      if (state.lessonQueue.length) return;
      state.lessonQueue = shuffle(pieceOrder);
      state.cycle += 1;
    }

    function randomSquare() {
      return Math.floor(Math.random() * 64);
    }

    function generateTask() {
      ensureLessonQueue();
      const pieceKey = state.lessonQueue.shift();
      return pieceKey === "pawn" ? generatePawnTask() : generateStandardTask(pieceKey);
    }

    function generateStandardTask(pieceKey) {
      let origin = randomSquare();
      let legal = [];
      let safety = 0;
      while (legal.length === 0 && safety < 200) {
        origin = randomSquare();
        legal = Array.from(getLegalMoves(pieceKey, origin, {}));
        safety += 1;
      }
      return {
        pieceKey,
        origin,
        legalMoves: legal,
        targets: new Set(legal),
        enemies: new Set(),
        allies: new Set([origin]),
        color: "white",
        prompt: `请点击一个 ${pieces[pieceKey].name} 可以一步走到的格子。`,
        meta: `起点：${coordName(origin)}`,
        solved: false,
        pawnMode: null,
      };
    }

    function generatePawnTask() {
      const color = Math.random() < 0.5 ? "white" : "black";
      const direction = color === "white" ? -1 : 1;
      const startRow = color === "white" ? 6 : 1;
      const mode = Math.random() < 0.55 ? "forward" : "capture";
      let origin;
      let targets = [];
      let enemies = new Set();
      let prompt = "";

      if (mode === "capture") {
        const possibleRows = color === "white" ? [1, 2, 3, 4, 5, 6] : [1, 2, 3, 4, 5, 6];
        for (let tries = 0; tries < 200; tries += 1) {
          const y = possibleRows[Math.floor(Math.random() * possibleRows.length)];
          const x = 1 + Math.floor(Math.random() * 6);
          origin = xyToIndex(x, y);
          const diagTargets = [];
          for (const dx of [-1, 1]) {
            const nx = x + dx;
            const ny = y + direction;
            if (inBoard(nx, ny)) diagTargets.push(xyToIndex(nx, ny));
          }
          if (diagTargets.length) {
            targets = [diagTargets[Math.floor(Math.random() * diagTargets.length)]];
            enemies = new Set(targets);
            break;
          }
        }
        prompt = `这是${color === "white" ? "白兵" : "黑兵"}吃子练习：请点击它可以吃到敌人的格子。`;
      } else {
        for (let tries = 0; tries < 200; tries += 1) {
          const yChoices = color === "white" ? [1, 2, 3, 4, 5, 6] : [1, 2, 3, 4, 5, 6];
          const y = yChoices[Math.floor(Math.random() * yChoices.length)];
          const x = Math.floor(Math.random() * 8);
          origin = xyToIndex(x, y);
          const oneY = y + direction;
          const twoY = y + direction * 2;
          const moves = [];
          if (inBoard(x, oneY)) moves.push(xyToIndex(x, oneY));
          if (y === startRow && inBoard(x, twoY)) moves.push(xyToIndex(x, twoY));
          if (moves.length) {
            targets = [moves[Math.floor(Math.random() * moves.length)]];
            break;
          }
        }
        prompt = `这是${color === "white" ? "白兵" : "黑兵"}前进练习：请点击它合法前进的位置。`;
      }

      return {
        pieceKey: "pawn",
        origin,
        legalMoves: targets,
        targets: new Set(targets),
        enemies,
        allies: new Set([origin]),
        color,
        prompt,
        meta: `起点：${coordName(origin)} · ${mode === "capture" ? "吃子" : "前进"}`,
        solved: false,
        pawnMode: mode,
      };
    }

    function getLegalMoves(pieceKey, origin, opts = {}) {
      const { x, y } = indexToXY(origin);
      const out = new Set();
      const addRay = (dirs) => {
        for (const [dx, dy] of dirs) {
          let nx = x + dx;
          let ny = y + dy;
          while (inBoard(nx, ny)) {
            out.add(xyToIndex(nx, ny));
            nx += dx;
            ny += dy;
          }
        }
      };

      switch (pieceKey) {
        case "king":
          for (let dx = -1; dx <= 1; dx += 1) {
            for (let dy = -1; dy <= 1; dy += 1) {
              if (dx === 0 && dy === 0) continue;
              const nx = x + dx;
              const ny = y + dy;
              if (inBoard(nx, ny)) out.add(xyToIndex(nx, ny));
            }
          }
          break;
        case "queen":
          addRay([
            [1, 0],
            [-1, 0],
            [0, 1],
            [0, -1],
            [1, 1],
            [1, -1],
            [-1, 1],
            [-1, -1],
          ]);
          break;
        case "rook":
          addRay([
            [1, 0],
            [-1, 0],
            [0, 1],
            [0, -1],
          ]);
          break;
        case "bishop":
          addRay([
            [1, 1],
            [1, -1],
            [-1, 1],
            [-1, -1],
          ]);
          break;
        case "knight": {
          const jumps = [
            [1, 2],
            [2, 1],
            [-1, 2],
            [-2, 1],
            [1, -2],
            [2, -1],
            [-1, -2],
            [-2, -1],
          ];
          for (const [dx, dy] of jumps) {
            const nx = x + dx;
            const ny = y + dy;
            if (inBoard(nx, ny)) out.add(xyToIndex(nx, ny));
          }
          break;
        }
        case "pawn": {
          const color = opts.color || "white";
          const mode = opts.mode || "forward";
          const dir = color === "white" ? -1 : 1;
          const startRow = color === "white" ? 6 : 1;
          if (mode === "forward") {
            if (inBoard(x, y + dir)) out.add(xyToIndex(x, y + dir));
            if (y === startRow && inBoard(x, y + dir * 2)) out.add(xyToIndex(x, y + dir * 2));
          } else {
            for (const dx of [-1, 1]) {
              if (inBoard(x + dx, y + dir)) out.add(xyToIndex(x + dx, y + dir));
            }
          }
          break;
        }
      }
      return out;
    }

    function getScoreForTryCount(tryNumber) {
      if (tryNumber <= 1) return 100;
      if (tryNumber === 2) return 50;
      return 25;
    }

    function currentPotential() {
      return getScoreForTryCount(state.triesForCurrent + 1);
    }

    function setMessage(text, kind = "") {
      el.messageBox.textContent = text;
      el.messageBox.className = `message${kind ? ` ${kind}` : ""}`;
    }

    function startNewTask() {
      state.currentTask = generateTask();
      state.triesForCurrent = 0;
      state.wrongClicks.clear();
      state.showHints = false;

      el.nextBtn.disabled = true;
      el.hintBtn.disabled = false;

      const info = pieces[state.currentTask.pieceKey];
      el.pieceSymbolChip.textContent = info.symbol;
      el.pieceNameChip.textContent = `${info.name}练习`;
      el.instructionText.textContent = state.currentTask.prompt;
      el.ruleText.textContent = `走法提示：${info.rule}`;
      el.taskMeta.textContent = `（${state.currentTask.meta}）`;
      setMessage("点击一个你认为正确的格子。");

      render();
    }

    function renderProgress() {
      el.pieceProgress.innerHTML = "";
      for (const key of pieceOrder) {
        const p = pieces[key];
        const done = state.learnedPieces.has(key);
        const div = document.createElement("div");
        div.className = `piece-pill${done ? " done" : ""}`;
        div.innerHTML = `<span>${p.symbol} ${p.name}</span><span class="tick">${done ? "✓" : "…"}</span>`;
        el.pieceProgress.appendChild(div);
      }
    }

    function renderStats() {
      el.totalScore.textContent = String(state.totalScore);
      el.solvedCount.textContent = String(state.solvedCount);
      el.tryCount.textContent = String(state.triesForCurrent + 1);
      el.currentPotential.textContent = String(currentPotential());
      renderProgress();
    }

    function getVisibleHints() {
      if (!state.showHints || !state.currentTask || state.currentTask.solved) return new Set();
      return new Set(state.currentTask.legalMoves);
    }

    function renderBoard() {
      const task = state.currentTask;
      const hintSet = getVisibleHints();
      el.board.innerHTML = "";

      for (let i = 0; i < 64; i += 1) {
        const { x, y } = indexToXY(i);
        const sq = document.createElement("button");
        sq.type = "button";
        sq.className = `square ${(x + y) % 2 === 0 ? "light" : "dark"}`;
        sq.dataset.index = String(i);

        if (i === task.origin) sq.classList.add("origin");
        if (task.solved && task.targets.has(i)) sq.classList.add("target");
        if (task.enemies.has(i)) sq.classList.add("enemy");
        if (hintSet.has(i)) sq.classList.add("valid-hint");
        if (state.wrongClicks.has(i)) sq.classList.add("wrong-click");

        if (i === task.origin) {
          const span = document.createElement("span");
          span.className = `piece ${task.color}`;
          span.textContent =
            task.color === "white"
              ? pieces[task.pieceKey].symbol
              : pieces[task.pieceKey].symbol.replace("♙", "♟");
          if (task.pieceKey !== "pawn" && task.color === "black") {
            const blackMap = {
              king: "♚",
              queen: "♛",
              rook: "♜",
              bishop: "♝",
              knight: "♞",
              pawn: "♟",
            };
            span.textContent = blackMap[task.pieceKey];
          }
          sq.appendChild(span);
        } else if (task.enemies.has(i)) {
          const enemy = document.createElement("span");
          enemy.className = "piece black";
          enemy.textContent = "♟";
          sq.appendChild(enemy);
        }

        const coord = document.createElement("span");
        coord.className = "coord";
        coord.textContent = coordName(i);
        sq.appendChild(coord);

        sq.addEventListener("click", onSquareClick);
        el.board.appendChild(sq);
      }
    }

    function render() {
      renderStats();
      renderBoard();
    }

    function onSquareClick(evt) {
      const task = state.currentTask;
      if (!task || task.solved) return;

      const index = Number(evt.currentTarget.dataset.index);
      if (Number.isNaN(index) || index === task.origin) {
        setMessage("请选择别的格子，起点格不能算答案。", "bad");
        return;
      }

      const isCorrect = task.targets.has(index);
      if (isCorrect) {
        const tryNumber = state.triesForCurrent + 1;
        const gained = getScoreForTryCount(tryNumber);
        state.totalScore += gained;
        state.solvedCount += 1;
        task.solved = true;
        state.learnedPieces.add(task.pieceKey);
        el.nextBtn.disabled = false;
        el.hintBtn.disabled = true;

        const levelText =
          gained === 100 ? "太棒了，一次就答对！" : gained === 50 ? "答对了！第二次完成也不错。" : "答对了！继续练习会越来越快。";
        setMessage(`${levelText} 本题得分：${gained} 分。`, "good");

        render();
        return;
      }

      state.triesForCurrent += 1;
      state.wrongClicks.add(index);
      setMessage(
        `这一步不对哦，再想想 ${pieces[task.pieceKey].name} 的走法。现在如果答对可得 ${currentPotential()} 分。`,
        "bad"
      );
      render();
    }

    el.nextBtn.addEventListener("click", () => {
      startNewTask();
    });

    el.hintBtn.addEventListener("click", () => {
      state.showHints = !state.showHints;
      el.hintBtn.textContent = state.showHints ? "隐藏提示点" : "显示提示点";
      setMessage(
        state.showHints
          ? "提示点已显示：绿色圆点表示合法落点。"
          : "提示点已隐藏，再试试自己判断。",
        state.showHints ? "good" : ""
      );
      render();
    });

    el.resetBtn.addEventListener("click", () => {
      state.totalScore = 0;
      state.solvedCount = 0;
      state.triesForCurrent = 0;
      state.learnedPieces.clear();
      state.lessonQueue = [];
      state.wrongClicks.clear();
      state.showHints = false;
      el.hintBtn.textContent = "显示提示点";
      startNewTask();
    });

    startNewTask();
  </script>
</body>
</html>
